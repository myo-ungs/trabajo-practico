\documentclass[a4paper,12pt]{article}
\usepackage[utf8]{inputenc}
\usepackage[T1]{fontenc}
\usepackage[spanish]{babel}
\usepackage{amsmath,amssymb,amsthm}
\usepackage{amsfonts}
\usepackage{enumitem}
\usepackage{geometry}
\geometry{margin=2.5cm}
\usepackage{fancyhdr}
\usepackage{graphicx}
\usepackage{listings}
\usepackage{xcolor}
\usepackage{longtable}
\usepackage{hyperref}
\hypersetup{
    colorlinks=true,
    linkcolor=black,
    filecolor=magenta,      
    urlcolor=cyan,
    pdftitle={Optimización de Picking},
    pdfpagemode=FullScreen,
}
\usepackage{tocloft}

\usepackage{booktabs}
\usepackage{multirow}
\usepackage[table]{xcolor}
\usepackage{tabularx} 

\renewcommand{\cfttoctitlefont}{\centering\Huge\bfseries}
\renewcommand{\cftsecfont}{\bfseries}
\renewcommand{\cftsecpagefont}{\bfseries}
\setlength{\cftbeforesecskip}{8pt}
\renewcommand{\cftsecleader}{\cftdotfill{\cftdotsep}}

\makeatletter
\let\old@tocline\@tocline
\def\@tocline#1#2#3#4#5#6#7{%
  \old@tocline{#1}{#2}{#3}{#4}{#5}{#6}{\textcolor{black}{#7}}%
}
\makeatother

\setcounter{section}{-1}
\usepackage{enumitem}
\usepackage[linesnumbered,ruled,vlined]{algorithm2e}
\SetKwInput{KwData}{Datos}
\SetKwInput{KwResult}{Resultado}
\SetKwComment{Comment}{$\triangleright$\ }{}


\begin{document}

\begin{titlepage}
    \centering
    \vspace*{0.9in}
    
    % Título del informe
    {\Huge \bfseries Informe de Entrega Final\par}
    
    \vspace{1in}
    
    % Universidad y materia
    {\LARGE \bfseries Universidad Nacional General Sarmiento \par}
    \vspace{0.3in}
    {\Large \textit{Modelado y Optimización} \par}
    \vspace{1in}
    {\Large \bfseries Profesor: \par}
    \vspace{0.3in}
    {\Large Marcelo Mydlarz \par}

    \vspace{0.6in}
    
    % Integrantes
    {\Large \bfseries Integrantes: \par}
    \vspace{0.3in}
    {\Large Juan Manuel Losada \par}
    \vspace{0.1in}
    {\Large Facundo Ruiz \par}
    \vspace{0.1in}
    {\Large Matías Morales \par}
    \vspace{0.1in}
    {\Large Vanesa Vera \par}

    \vspace{1in}
    
    % Fecha
    % Pie de página opcional
    \vfill
    {\Large 26 de Junio 2025 \par}
    
\end{titlepage}

% Configuración de encabezados y pies de página
\pagestyle{fancy}
\fancyhf{}
\lhead{Modelado y Optimización}
\rhead{\thepage}
\cfoot{}

% Definición de entornos
\newtheorem{theorem}{Teorema}
\newtheorem{lemma}{Lema}
\newtheorem{definition}{Definición}
\newtheorem{problem}{Problema}

% Configuración de listings
\lstdefinestyle{PythonStyle}{
  language=Python,
  basicstyle=\ttfamily\footnotesize,
  keywordstyle=\color{blue}\bfseries,
  commentstyle=\color{green!60!black}\itshape,
  stringstyle=\color{red!80!black},
  numberstyle=\tiny\color{gray},
  showstringspaces=false,
  tabsize=2,
  breaklines=true,
  breakatwhitespace=true,
  numbers=left,
  frame=tb,
  framesep=5pt,
  framexleftmargin=2pt,
  captionpos=b,
  extendedchars=true,
  inputencoding=utf8,
  literate={á}{{\'a}}1 {é}{{\'e}}1 {í}{{\'i}}1 {ó}{{\'o}}1 {ú}{{\'u}}1 {Á}{{\'A}}1 {É}{{\'E}}1 {Í}{{\'I}}1 {Ó}{{\'O}}1 {Ú}{{\'U}}1 {ñ}{{\~n}}1 {Ñ}{{\~N}}1
}
\lstset{style=PythonStyle}


%====================================================================
% CARÁTULA
%====================================================================
\thispagestyle{empty}
\clearpage

\tableofcontents
\clearpage

%====================================================================
\section{Introducción}
%====================================================================
En este informe se presentan los resultados obtenidos tras la resolución de los problemas planteados, que incluyen unos problemas iniciales bajo el contexto \textit{Entrada en Calor} y, principalmente, el problema central denominado \textit{El Desafío}. El análisis se centra especialmente en las partes 4 a 7, que abordan la resolución integral y la mejora del problema.

\subsection*{Descripción de los problemas}

A continuación se describen brevemente los problemas de la entrada en calor y las diferentes etapas del \textit{Desafío}, poniendo énfasis en las fases 4 a 7 que constituyen el núcleo del estudio.

\begin{itemize}
    \item \textbf{Problemas iniciales (entrada en calor):}  
    \begin{itemize}
        \item \textit{Problema 1:} Selección óptima de un único contenedor para abastecer un conjunto de bolsitas, maximizando el beneficio total.  
        \item \textit{Problema 2:} Generalización del anterior, permitiendo seleccionar múltiples contenedores para cubrir las demandas, incrementando la flexibilidad y complejidad.
    \end{itemize}

    \item \textbf{Partes 1 a 3 del Desafío:}  
    Se abordan formulaciones iniciales para la selección de pasillos con cantidad fija (\textit{Parte 1}), selección con pasillos específicos (\textit{Parte 2}) y una estrategia avanzada basada en generación de columnas para manejar instancias grandes (\textit{Parte 3}).

    \item \textbf{Partes 4 a 7:} \textit{(Enfoque principal de este informe)}  
    \begin{itemize}
        \item \textit{Parte 4:} Implementación de un método iterativo que explora diferentes cantidades de pasillos a seleccionar y refina la solución fijando pasillos para optimizar la selección de órdenes. Se garantiza el respeto al límite de tiempo total asignado.
        
        \item \textit{Parte 5:} Extensión de la parte 4, incorporando generación de columnas para mejorar la solución en problemas de gran escala.
        
        \item \textit{Parte 6:} Evaluación y propuesta de mejoras para la generación de columnas, como selección inicial eficiente, mejoras en la función de ranking y eliminación de columnas no utilizadas.
        
        \item \textit{Parte 7:} Integración opcional de las mejoras anteriores junto con modelos no lineales, técnicas de inteligencia artificial y metodologías avanzadas (por ejemplo, Branch \& Price), con el objetivo de competir eficazmente con diversas instancias del problema.
    \end{itemize}
\end{itemize}

\subsection*{Definiciones importantes}

\subsubsection*{Entrada en Calor:}

\begin{itemize}
    \item $I$: conjunto de ítems.
    \item $O$ de bolsitas. Cada bolsita $o \in O$ contiene ítems del conjunto $I$. El ítem $i \in I$ aparece $u_{oi}$ veces en la bolsita $o$.
    \item $A$: conjunto de contenedores. Cada contenedor $a \in A$ contiene ítems del conjunto $I$. El ítem $i \in I$ aparece $u_{ai}$ veces en el contenedor $a$.
    \item $b_{oi}$: beneficio del ítem $i$ en la bolsita $o$.
    \item $b_a$: beneficio asociado al contenedor $a$.
    
\end{itemize}

\subsubsection*{El Desafío:}

\begin{itemize}
    \item $O$: conjunto de órdenes.
    \item $I$: conjunto de elementos.
    \item $A$: conjunto de pasillos.
    \item $LB$: límite inferior de unidades a recolectar.
    \item $UB$: límite superior de unidades a recolectar.
\end{itemize}


% \subsection*{Parámetros del Sistema}

% \subsubsection*{Entrada en Calor:} 

% \begin{itemize}
%     \item $c_{jt}$: Cantidad del producto $t$ requerida por la orden $j$
%     \item $d_{kt}$: Cantidad del producto $t$ disponible en el pasillo $k$
%     \item $\beta_j$: Beneficio obtenido al seleccionar la orden $j$
%     \item $\alpha_k$: Costo de utilizar el pasillo $k$
%     \item $L_w, U_w$: Límites inferior y superior para la ola de trabajo (wave), que definen el rango permitido para la cantidad total de productos procesados
% \end{itemize}

% \subsubsection*{El Desafío:}

% \begin{itemize}
%     \item $c_{jt}$: Cantidad del producto $t$ requerida por la orden $j$
%     \item $d_{kt}$: Cantidad del producto $t$ disponible en el pasillo $k$

% \end{itemize}

\subsection*{Formato de Datos de Entrada}

Los datos del problema se proporcionan en archivos de texto estructurados con el siguiente formato:

% \subsubsection*{Entrada en Calor:}

% \begin{itemize}
%     \item \textbf{Primera línea:} contiene tres enteros $o$, $i$, $a$ que indican la cantidad de bolsitas, el número de items diferentes y la cantidad de contenedores, respectivamente.
%     \item \textbf{Siguientes $o$ líneas:} cada línea comienza con un entero \(k\), seguido por \(k\) pares de enteros, representando el número del item y la cantidad de veces que aparece en la bolsita. Dentro de este grupo de líneas, y para \(j \in \{1, \ldots, o\}\), la \(j\)-ésima línea contiene datos relacionados con la bolsita indexada por \(j-1\), significando que las bolsitas están numeradas de \(0\) a \(o-1\). Además, se asume que los items están indexados de \(0\) a \(i-1\).
%     \item \textbf{Siguientes $J$ líneas:} cada línea comienza con un entero \(l\), seguido por \(l\) pares de enteros, representando el número del item y el número de unidades disponibles en el contenedor. Similar al caso de las bolsitas, dentro de este grupo de líneas, y para \(j \in \{1, \ldots, a\}\), la \(j\)-ésima línea contiene datos relacionados con el contenedor indexado por \(j-1\), significando que los contenedores están numerados de \(0\) a \(a-1\).
% \end{itemize}

\subsubsection*{El Desafío:}

\begin{itemize}
    \item \textbf{Primera línea:} contiene tres enteros $o$, $i$, $a$ que indican la cantidad de órdenes, la cantidad de elementos diferentes y la cantidad de pasillos, respectivamente.

    \item \textbf{Siguientes $o$ líneas:} cada línea representa una orden. 
    \begin{itemize}
        \item Cada línea comienza con un entero $k$, que indica la cantidad de elementos distintos solicitados en la orden.
        \item Luego siguen $k$ pares de números $(e_j, q_j)$ donde:
        \begin{itemize}
            \item $e_j$ es el índice del elemento solicitado.
            \item $q_j$ es la cantidad requerida del elemento $e_j$.
        \end{itemize}
    \end{itemize}

    \item \textbf{Siguientes $a$ líneas:} cada línea representa un pasillo.
    \begin{itemize}
        \item Cada línea comienza con un entero $l$, que indica la cantidad de tipos de elementos disponibles en ese pasillo.
        \item Luego siguen $l$ pares de números $(e_k, s_k)$ donde:
        \begin{itemize}
            \item $e_k$ es el índice del elemento disponible.
            \item $s_k$ es la cantidad disponible del elemento $e_k$ en ese pasillo.
        \end{itemize}
    \end{itemize}

    \item \textbf{Última línea:} contiene dos enteros $LB$ y $UB$, que representan el límite inferior y superior de unidades a recolectar, respectivamente.
\end{itemize}

\clearpage

\section{Parte 4}
\label{sec:variante4}

\begin{enumerate}[label=(\alph*), leftmargin=2em]
    \item \textbf{Modelos matemáticos utilizados:}
    \begin{enumerate}[label=\roman*., leftmargin=0.2em]
        \item Descripción del problema que resuelve cada modelo.

            En esta etapa se aborda la resolución integral del problema \textit{Desafío}, integrando las estrategias desarrolladas en las partes anteriores. Para ello, se implementa el método \texttt{Opt\_ExplorarCantidadPasillos(umbral)}, que ejecuta de forma iterativa el modelo propuesto en la primera parte del desafio (función \texttt{Opt\_cantidadPasillosFija}), donde se considera una cantidad fija \(k\) de pasillos a seleccionar.
    
            Los valores de \(k\) se determinan a partir de la función \texttt{Rankear}, que estima el potencial de cada valor en función de la capacidad acumulada de los pasillos. Por cada \(k\), se ejecuta el modelo de la primera parte dentro del tiempo asignado, y se conserva la mejor solución encontrada.
            
            Una vez finalizada la etapa exploratoria, se fijan los pasillos de la mejor solución obtenida y se aplica el modelo de la segunda parte del desafio (función \texttt{Opt\_PasillosFijos}), que refina la selección de órdenes en base a la disponibilidad real de los pasillos previamente seleccionados.
            
            Este enfoque permite encontrar una solución final más eficiente, combinando exploración amplia (con múltiples valores de \(k\)) y una etapa de mejora local. Se garantiza que el tiempo total de ejecución del método \texttt{Opt\_ExplorarCantidadPasillos(umbral)} no exceda el umbral de tiempo especificado.
            
        \item Definición de variables utilizadas.

            \begin{itemize}
                \item \(x_o \in \{0,1\}\): variable binaria que indica si la orden \(o\) es seleccionada (\(1\)) o no (\(0\)).
                \item \(y_a \in \{0,1\}\): variable binaria que indica si el pasillo \(a\) es seleccionado (\(1\)) o no (\(0\)).
                \item Parámetros:
                \begin{itemize}
                    \item \(W_{o,i}\): cantidad del elemento \(i\) en la orden \(o\).
                    \item \(S_{a,i}\): capacidad disponible del elemento \(i\) en el pasillo \(a\).
                    \item \(\mathrm{LB}\): límite inferior de la cantidad total de elementos a recolectar.
                    \item \(\mathrm{UB}\): límite superior de la cantidad total de elementos a recolectar.
                    \item \(k\): cantidad fija de pasillos a visitar en la etapa exploratoria.
                \end{itemize}
            \end{itemize}

        \item Modelo matemático completo.

            Para un valor fijo de \(k\), el modelo a optimizar es:

            \[
            \begin{aligned}
            \max \quad & \sum_{o=1}^{n} \sum_{i=1}^{m} W_{o,i} \cdot x_o \\
            \text{s.t} \quad
            & \mathrm{LB} \leq \sum_{o=1}^n \sum_{i=1}^m W_{o,i} \cdot x_o \leq \mathrm{UB} \\
            & \sum_{o=1}^n W_{o,i} \cdot x_o \leq \sum_{a \in P_k} S_{a,i} \cdot y_a, \quad \forall i = 1,\ldots,m \\
            & \sum_{a \in P_k} y_a = k \\
            & x_o \in \{0,1\}, \quad y_a \in \{0,1\}
            \end{aligned}
            \]

            donde \(P_k\) es el conjunto de pasillos considerados para la cantidad fija \(k\), determinado por la función \texttt{Rankear} y la reutilización de soluciones previas.

            Luego, con los pasillos fijos seleccionados \(\hat{P}\), se resuelve el modelo de refinamiento:

            \[
            \begin{aligned}
            \max \quad & \sum_{o=1}^{n} \sum_{i=1}^{m} W_{o,i} \cdot x_o \\
            \text{s.t} \quad
            & \mathrm{LB} \leq \sum_{o=1}^n \sum_{i=1}^m W_{o,i} \cdot x_o \leq \mathrm{UB} \\
            & \sum_{o=1}^n W_{o,i} \cdot x_o \leq \sum_{a \in \hat{P}} S_{a,i}, \quad \forall i = 1,\ldots,m \\
            & x_o \in \{0,1\}
            \end{aligned}
            \]

        \item Explicación de la función objetivo y las restricciones.

            \begin{itemize}
                \item \textbf{Función objetivo:} maximizar la cantidad total de elementos recolectados, representado por la suma ponderada de elementos en las órdenes seleccionadas.
                \item \textbf{Restricciones:}
                \begin{itemize}
                    \item La suma total de elementos recolectados debe estar dentro de los límites inferiores y superiores (\(\mathrm{LB}\) y \(\mathrm{UB}\)), garantizando que la solución sea viable y esté dentro de los parámetros deseados.
                    \item La cantidad total de cada elemento recolectado no puede exceder la capacidad disponible de los pasillos seleccionados.
                    \item En la primera etapa, se seleccionan exactamente \(k\) pasillos.
                    \item Las variables \(x_o\) y \(y_a\) son binarias, lo que refleja decisiones de inclusión o exclusión de órdenes y pasillos, respectivamente.
                \end{itemize}
            \end{itemize}
    \end{enumerate}

    \item \textbf{Pseudocódigo a alto nivel del algoritmo:}

    
    % Aumentar espacio vertical entre líneas
    \setlength{\algomargin}{1em}
    \setlength{\lineskip}{1.2em} % Esto puede ayudar, pero no siempre funciona
    
    % O agregar espacio extra entre comandos
    \newcommand{\myvspace}{\vspace{0.3em}}
    
    % Código del algoritmo:
    \begin{algorithm}[H]
    \KwData{\texttt{umbral\_total} \myvspace}
    \KwResult{Mejor solución encontrada \myvspace}
    
    % --- Inicialización ---
    Inicializar $tiempo\_inicio \gets$ tiempo actual\;\myvspace
    Inicializar $mejor\_valor \gets -\infty$\;\myvspace
    Inicializar $mejor\_solución \gets \emptyset$\;\myvspace
    Crear lista $ranking\_k \gets \{1, 2, \ldots, n\_pasillos\}$\;\myvspace
    
    % --- Exploración iterativa ---
    \ForEach{$k$ en $ranking\_k$}{
        $tiempo\_restante \gets umbral\_total - (tiempo\ actual - tiempo\_inicio)$\;\myvspace
        
        \If{$tiempo\_restante \leq 0$}{
            \textbf{salir} del ciclo \tcp*
        }
        
        $solución_k \gets$ ejecutar \texttt{Opt\_cantidadPasillosFija}$(k, tiempo\_restante)$\;\myvspace
        
        \If{$solucion_k$ es válida \textbf{y} $solucion_k.valor\_objetivo > mejor\_valor$}{
            $mejor\_valor \gets solucion_k.valor\_objetivo$\;\myvspace
            $mejor\_solucion \gets solución_k$\;\myvspace
        }
    }
    
    % --- Refinamiento con pasillos fijos ---
    Fijar $pasillos\_fijos \gets$ pasillos seleccionados en $mejor\_solucion$\;\myvspace
    
    $tiempo\_restante \gets umbral\_total - (tiempo\ actual - tiempo\_inicio)$\;\myvspace
    
    \If{$tiempo\_restante > 0$}{
        $solucion\_refinada \gets$ ejecutar \texttt{Opt\_PasillosFijos}$(tiempo\_restante)$\;\myvspace
        
        \If{$solución\_refinada$ es válida \textbf{y} $solución\_refinada.valor\_objetivo > mejor\_valor$}{
            $mejor\_solución \gets solución\_refinada$\;\myvspace
        }
    }
    
    \Return $mejor\_solucion$\;
    
    \caption{Algoritmo de exploración y refinamiento para selección de pasillos}
    \end{algorithm}

\end{enumerate}


\clearpage

\section{Parte 5}
\label{sec:variante5}

\begin{enumerate}[label=(\alph*), leftmargin=2em]
    \item \textbf{Modelos matemáticos utilizados:}
    \begin{enumerate}[label=\roman*., leftmargin=0.2em]
    
        \item Descripción del problema que resuelve cada modelo.
        
            En esta etapa se resuelve el problema \textit{Desafío} mediante un enfoque de generación de columnas (o patrones). Cada columna representa un conjunto factible de órdenes que pueden ser atendidas por un único pasillo. Estas columnas se generan dinámicamente durante el proceso de optimización.

            Se implementa una clase \texttt{Columns} que contiene tres métodos principales:
            \begin{itemize}
                \item \texttt{Opt\_cantidadPasilloFija(k, umbral)}: resuelve el problema para una cantidad fija \(k\) de pasillos seleccionados, dentro de un límite de tiempo dado.
                \item \texttt{Opt\_PasillosFijos(umbral)}: dado un conjunto fijo de pasillos, encuentra la mejor selección de órdenes compatible con ellos.
                \item \texttt{Opt\_ExplorarCantidadPasillos(umbral)}: explora distintos valores de \(k\), ejecutando el modelo con generación de columnas y eligiendo la mejor solución dentro del tiempo total disponible.
            \end{itemize}

            En cada iteración de \texttt{Opt\_ExplorarCantidadPasillos}, se ejecuta \texttt{Opt\_cantidadPasilloFija} para un valor \(k\), basado en una estrategia de ranking que estima el potencial de cada valor. Se agregan nuevas columnas basadas en los valores duales hasta que no se pueden generar más columnas o se agota el tiempo.

            Finalmente, se fija el mejor conjunto de pasillos encontrados y se ejecuta \texttt{Opt\_PasillosFijos} para refinar la solución.

        \item Definición de variables utilizadas.

            \begin{itemize}
                \item \(x_j \in \{0,1\}\): variable binaria que indica si la columna (patrón) \(j\) es seleccionada.
                \item \(a_j\): pasillo asociado a la columna \(j\).
                \item \(o_{jo} \in \{0,1\}\): parámetro que vale 1 si la orden \(o\) está incluida en la columna \(j\), y 0 en caso contrario.
                \item \(W_{o,i}\): cantidad del elemento \(i\) en la orden \(o\).
                \item \(k\): cantidad fija de pasillos seleccionados (\(|A'|\)).
            \end{itemize}

        \item Modelo matemático completo.

            Para un conjunto de columnas \(C_k\) generado para una cantidad fija de pasillos \(k\):

            \[
            \begin{aligned}
            \max \quad & \sum_{j \in C_k} x_j \cdot \sum_{o \in O} \left( \sum_{i \in I} W_{o,i}  \cdot o_{jo}\right) \\
            \text{s.t.} \quad
            & \sum_{j \in C_k} x_j = k & \text{(Selección de exactamente $k$ pasillos)} \\
            & \sum_{j \in C_k} x_j \cdot o_{jo} \leq 1 & \forall o \in O \quad \text{(Cada orden a lo sumo una vez)} \\
            & x_j \in \{0,1\} & \forall j \in C_k
            \end{aligned}
            \]

        \item Explicación de la función objetivo y las restricciones.

            \begin{itemize}
                \item \textbf{Función objetivo:} maximizar la cantidad total de elementos entregados por las órdenes incluidas en las columnas seleccionadas. Cada columna contribuye con el total de elementos de las órdenes que contiene.
                
                \item \textbf{Restricciones:}
                \begin{itemize}
                    \item Se seleccionan exactamente \(k\) columnas, es decir, \(k\) pasillos.
                    \item Cada orden puede ser cubierta a lo sumo por una columna, evitando duplicidad.
                    \item Las variables \(x_j\) son binarias, reflejando decisiones de inclusión o exclusión de columnas (patrones).
                \end{itemize}
            \end{itemize}

    \end{enumerate}

    \item \textbf{Pseudocódigo a alto nivel del algoritmo:}
\end{enumerate}

\clearpage

\section{Parte 6}
\label{sec:variante6}

\begin{enumerate}[label=(\alph*), leftmargin=2em]
    \item \textbf{Modelos matemáticos utilizados:}
    \begin{enumerate}[label=\roman*., leftmargin=0.2em]
    
        \item Descripción del problema que resuelve cada modelo.
        
            En esta etapa se busca mejorar la performance del modelo desarrollado en la Parte 5, manteniendo su estructura de generación de columnas, pero introduciendo variantes que optimizan distintas etapas del proceso. 

            Las siguientes alternativas fueron evaluadas por separado:

            \begin{enumerate}[label=\arabic*.]
                \item \textbf{Columnas iniciales eficientes:} mejora en la generación de columnas iniciales, seleccionando pasillos con mayor capacidad.
                \item \textbf{Rankear mejorado:} utiliza KMeans para agrupar pasillos por capacidad y priorizar valores de \(k\) representativos.
                \item \textbf{Eliminar columnas inactivas:} elimina columnas no utilizadas en varias iteraciones para reducir el tamaño del modelo maestro.
            \end{enumerate}

            Cada una de estas variantes se evalúa por separado frente al modelo base de la Parte 5, sobre las primeras 4 instancias del conjunto de datos. Se implementa un script que automatiza la ejecución de cada modelo con los mismos inputs y condiciones, y que genera un archivo CSV con métricas comparativas.

        \item Definición de variables utilizadas.

            Las variables del modelo son las mismas que en la Parte 5:

            \begin{itemize}
                \item \(x_j \in \{0,1\}\): variable binaria que indica si la columna (patrón) \(j\) es seleccionada.
                \item \(a_j\): pasillo asociado a la columna \(j\).
                \item \(o_{jo} \in \{0,1\}\): parámetro que vale 1 si la orden \(o\) está incluida en la columna \(j\), 0 en caso contrario.
                \item \(W_{o,i}\): cantidad del elemento \(i\) en la orden \(o\).
                \item \(k\): cantidad de pasillos a seleccionar en la iteración actual.
            \end{itemize}

        \item Modelo matemático completo.

            Se mantiene el mismo modelo matemático base de la Parte 5:

            \[
            \begin{aligned}
            \max \quad & \sum_{j \in C_k} x_j \cdot \sum_{o \in O} \left( \sum_{i \in I} W_{o,i}  \cdot o_{jo}\right) \\
            \text{s.t.} \quad
            & \sum_{j \in C_k} x_j = k & \text{(Selección de exactamente $k$ pasillos)} \\
            & \sum_{j \in C_k} x_j \cdot o_{jo} \leq 1 & \forall o \in O \quad \text{(Cada orden a lo sumo una vez)} \\
            & x_j \in \{0,1\} & \forall j \in C_k
            \end{aligned}
            \]

            Lo que cambia es la lógica de selección y evolución del conjunto \(C_k\) de columnas:

            \begin{itemize}
                \item En la variante (1), \(C_k\) se inicializa con las columnas optimizadas.
                \item En la variante (2), los valores de \(k\) que se exploran se priorizan con una nueva función \texttt{Rankear}.
                \item En la variante (3), en cada iteración se eliminan del modelo las columnas no utilizadas en las últimas iteraciones, manteniendo actualizado el conjunto \(C_k\).
            \end{itemize}

        \item Explicación de la función objetivo y las restricciones.

            \begin{itemize}
                \item \textbf{Función objetivo:} se busca maximizar la cantidad total de elementos entregados, considerando las órdenes incluidas en las columnas seleccionadas.
                \item \textbf{Restricciones:}
                \begin{itemize}
                    \item Se seleccionan exactamente \(k\) columnas/pasillos.
                    \item Cada orden puede ser cubierta por una única columna.
                    \item Las variables \(x_j\) indican si se incluye la columna/patrón en la solución final.
                \end{itemize}
            \end{itemize}

    \end{enumerate}

    \item \textbf{Pseudocódigo a alto nivel del algoritmo:}
\end{enumerate}

\clearpage

\section{Parte 7}
\label{sec:variante5}

\begin{enumerate}[label=(\alph*), leftmargin=2em]
    \item \textbf{Modelos matemáticos utilizados:}
    \begin{enumerate}[label=\roman*., leftmargin=0.2em]
    
        \item \textbf{Descripción del problema que resuelve cada modelo.}
        
        En esta etapa tambíen se aborda el \textit{Desafío(|A'|)} mediante dos enfoques complementarios:

        \begin{itemize}
            \item \textbf{FastSolver:} un solucionador heurístico diseñado para instancias grandes. Utiliza una heurística greedy que selecciona los pasillos con mayor capacidad y luego agrega órdenes de mayor beneficio siempre que su demanda no exceda la capacidad total. Luego aplica una mejora por búsqueda local mediante intercambio de órdenes.
            
            \item \textbf{Columns (mejorado):} una extensión del modelo exacto con generación de columnas. Implementa mejoras de la Parte 6 como:
            \begin{itemize}
                \item Selección inicial de columnas basada en pasillos con mayor capacidad,
                \item Rankeo de valores de \(k\) usando KMeans para priorizar subconjuntos de pasillos representativos,
                \item Eliminación dinámica de columnas no utilizadas durante las iteraciones.
            \end{itemize}
            Este modelo construye iterativamente un conjunto de columnas factibles y optimiza la combinación lineal entera de las mismas, resolviendo subproblemas hasta alcanzar una solución cercana al óptimo.
        \end{itemize}

         Si la instancia es pequeña se usa el modelo exacto, y si es grande se preprocesa la instancia y se aplica FastSolver.

        \item \textbf{Definición de variables utilizadas.}

        \textit{En el modelo de generación de columnas:}
        \begin{itemize}
            \item \( z_j \in \{0,1\} \): variable que indica si la columna \(j\) es seleccionada.
            \item \( c_j \): beneficio o cantidad total de ítems de las órdenes en la columna \(j\).
            \item \( o_{jo} \in \{0,1\} \): parámetro que vale 1 si la orden \(o\) está contenida en la columna \(j\).
            \item \( k \): cantidad de pasillos seleccionados.
        \end{itemize}

        \textit{En FastSolver:}
        \begin{itemize}
            \item Listas de índices de órdenes y pasillos seleccionados.
            \item \( capacidad\_total[i] \): capacidad disponible del ítem \(i\) considerando los pasillos elegidos.
            \item \( demanda\_usada[i] \): demanda acumulada del ítem \(i\).
            \item \( valor\_objetivo \): beneficio acumulado por las órdenes aceptadas.
        \end{itemize}

        \item \textbf{Modelo matemático completo.}

        El modelo general de generación de columnas se puede formular como:

        \[
        \begin{aligned}
        \max \quad & \sum_{j \in \mathcal{C}} c_j z_j \\
        \text{sujeto a} \quad
        & \sum_{j \in \mathcal{C}} z_j \cdot o_{jo} \leq 1 & \forall o \in \mathcal{O} \quad \text{(cada orden a lo sumo una vez)} \\
        & LB \leq \sum_{j \in \mathcal{C}} c_j z_j \leq UB & \text{(cantidad total de órdenes)} \\
        & z_j \in \{0,1\} & \forall j \in \mathcal{C}
        \end{aligned}
        \]

        Donde \( \mathcal{C} \) es el conjunto de columnas generadas, y \( \mathcal{O} \) es el conjunto de órdenes.

        \item \textbf{Explicación de la función objetivo y las restricciones.}

        \begin{itemize}
            \item \textbf{Función objetivo:} maximizar el beneficio total de las órdenes seleccionadas a través de las columnas elegidas. Este beneficio suele estar dado por la cantidad total de ítems cubiertos.
            
            \item \textbf{Restricciones:}
            \begin{itemize}
                \item Cada orden puede ser cubierta a lo sumo una vez.
                \item La cantidad total de órdenes seleccionadas debe estar dentro del intervalo \([LB, UB]\).
                \item Las variables son binarias, reflejando decisiones de activación de columnas.
            \end{itemize}
        \end{itemize}

    \end{enumerate}


    \item \textbf{Pseudocódigo a alto nivel del algoritmo:}
\end{enumerate}

\clearpage

\section{Resultados en tablas}
En esta sección mostraremos los resultados obtenidos.

\subsection{Parte 6}
En la siguiente tabla se presentan los resultados obtenidos al evaluar distintas estrategias para mejorar la performance del modelo de la Sección 5. Se considera, por separado, la incorporación de cada una de las siguientes variantes: selección más eficiente de columnas iniciales, mejora de la función \texttt{Rankear}, y eliminación de columnas no utilizadas en las últimas iteraciones. Las pruebas se realizaron sobre las primeras cuatro instancias del conjunto de datos \texttt{A}.

\begin{table}[h!]
\centering
\renewcommand{\arraystretch}{1.2}
\begin{tabular}{llcccc}
\toprule
\textbf{Instancia} & \textbf{Métrica} & \textbf{Sección 5} & \textbf{Col. iniciales} & \textbf{Rankear} & \textbf{Elim col.} \\
\midrule
\multirow{5}{*}{A-0001} 
  & Restricciones         & 157 & 157 & 157 & 157 \\
  & \# var iniciales      & 17  & 17  & 17  & 17  \\
  & \# var últ. maestro   & 18  & 17  & 18  & 17  \\
  & Cota dual             & 51.0& 51.0& 51.0& 51  \\
  & Mejor objetivo        & 68  & 68  & 68  & 68  \\
\midrule
\multirow{5}{*}{A-0002} 
  & Restricciones         & 9   & 9   & 9   & 9   \\
  & \# var iniciales      & 6   & 6   & 6   & 6   \\
  & \# var últ. maestro   & 6   & 6   & 6   & 6   \\
  & Cota dual             & 8.0 & 8.0 & 8.0 & 8   \\
  & Mejor objetivo        & 2   & 2   & 2   & 2   \\
\midrule
\multirow{5}{*}{A-0003} 
  & Restricciones         & 248 & 248 & 248 & 248 \\
  & \# var iniciales      & 14  & 14  & 14  & 14  \\
  & \# var últ. maestro   & 15  & 15  & 15  & 14  \\
  & Cota dual             & 50.0& 50.0& 50.0& 50  \\
  & Mejor objetivo        & 68  & 68  & 68  & 75  \\
\midrule
\multirow{5}{*}{A-0004} 
  & Restricciones         & 0   & 0   & 0   & 0   \\
  & \# var iniciales      & 0   & 0   & 0   & 0   \\
  & \# var últ. maestro   & 0   & 0   & 0   & 0   \\
  & Cota dual             & 0   & 0   & 0   & 0   \\
  & Mejor objetivo        & 0   & 0   & 0   & 0   \\
\bottomrule
\end{tabular}
\caption{Comparación de métricas por instancia y estrategia}
\end{table}

\clearpage

\subsection{Parte 7}
La siguiente tabla presenta una comparación entre el mejor modelo obtenido en la Parte 6 y el modelo propuesto en la Parte 7, utilizando las primeras tres instancias del conjunto de datos \texttt{A} y del conjunto de datos \texttt{B}.

\begin{table}[h!]
\centering
\renewcommand{\arraystretch}{1.2}
\begin{tabularx}{\textwidth}{lXcc}
\toprule
\textbf{Instancia} & \textbf{Métrica} & \textbf{Parte 6} & \textbf{Parte 7} \\
\midrule
\multirow{5}{*}{A\_instance\_0001} 
  & Restricciones               & 157   & 157   \\
  & \# variables iniciales      & 17  & 17   \\
  & \# variables últ. maestro   & 17  & 17  \\
  & Cota dual                   & 51  & 51  \\
  & Mejor objetivo              & 68   & 68  \\
\midrule
\multirow{5}{*}{A\_instance\_0002} 
  & Restricciones               & 9   & 9  \\
  & \# variables iniciales      & 6   & 6   \\
  & \# variables últ. maestro   & 6   & 6   \\
  & Cota dual                   & 8   & 8   \\
  & Mejor objetivo              & 2   & 2   \\
\midrule
\multirow{5}{*}{A\_instance\_0003} 
  & Restricciones               & 248   & 248   \\
  & \# variables iniciales      & 14   & 14 \\
  & \# variables últ. maestro   & 14   & 14   \\
  & Cota dual                   & 50   & 50   \\
  & Mejor objetivo              & 75   & 75   \\
\midrule
\multirow{5}{*}{B\_instance\_0001} 
  & Restricciones               & 0   & 7675   \\
  & \# variables iniciales      & 7   & 30   \\
  & \# variables últ. maestro   & 7   & 30   \\
  & Cota dual                   & 0   & 350   \\
  & Mejor objetivo              & 0   & 350   \\
\midrule
  \multirow{5}{*}{B\_instance\_0002} 
  & Restricciones               & 0   & 5922   \\
  & \# variables iniciales      & 5   & 30   \\
  & \# variables últ. maestro   & 5   & 30   \\
  & Cota dual                   & 0   & 3450   \\
  & Mejor objetivo              & 0   & 3450   \\
\midrule
\multirow{5}{*}{B\_instance\_0003} 
  & Restricciones               & 0   & 5617   \\
  & \# variables iniciales      & 4   & 30   \\
  & \# variables últ. maestro   & 4   & 30   \\
  & Cota dual                   & 0   & 2150   \\
  & Mejor objetivo              & 0   & 2150   \\
\bottomrule
\end{tabularx}
\caption{Comparación entre el mejor modelo de la Parte 6 y el de la Parte 7 para las instancias del dataset A}
\end{table}

\clearpage
%====================================================================
\section{Conclusiones}
%====================================================================

\textbf{Dificultades:}

\begin{enumerate}

    \item \textbf{Generación de Nuevas Columnas}
    
    En la inicialización del modelo, se incluían todas las columnas posibles, lo que provocaba que las columnas candidatas generadas por la función \texttt{buscar\_columna\_mejoradora()} no agregue ninguna columna por el hecho de que todas opciones estaban incluidas en el conjunto inicial, entonces al llamar a \texttt{agregar\_columna()} las columnas estaban siendo detectadas como duplicadas y por lo tanto no agregadas al modelo. Entonces el modelo ya estaba saturado, consume más memoria y tiempo, ya que el método de generación de columnas no hacía nada. 
    
    \emph{Solución:} Se modificó la estrategia de inicialización de columnas, reduciendo el conjunto inicial a un subconjunto más pequeño y representativo: columnas con una sola orden cada una. Esta nueva configuración constituye un punto de partida factible, pero no saturado de columnas repetidas, lo que permite que el método agregue nuevas columnas y mejore iterativamente la solución.

    \item \textbf{Instancias grandes}
    
    Durante el desarrollo observamos que, al ejecutar el modelo exacto con generación de columnas sobre algunas instancias grandes, como las que se encuentran en la carpeta \texttt{"b"} el tiempo de cómputo aumentaba considerablemente y en algunos casos el proceso quedaba detenido indefinidamente sin devolver resultados. Esto se debe a que, en estos casos, la generación de nuevas columnas es costosa y el solver puede requerir resolver modelos con miles de variables binarios en múltiples iteraciones, lo cual resulta inviable en un entorno con recursos limitados.
    
    \emph{Solución:} Para abordar esta limitación, se diseñó e implementó un modelo heurístico \texttt{FastSolver}, utilizado en la sección 7, que permite obtener soluciones factibles de buena calidad en tiempos significativamente menores. Este enfoque se basa en una heurística greedy para seleccionar pasillos y órdenes, complementada con una búsqueda local que mejora la solución inicial. Si bien no garantiza optimalidad, su eficiencia lo convierte en una herramienta clave para tratar instancias de gran escala. Para la sección 5 se agregó un timer que corta la ejecución en los modelos que no terminan por su tamaño, y se determinó que estos no tienen solución. 

\end{enumerate}

\textbf{Principales aprendizajes obtenidos:}

\begin{itemize}
    \item \textbf{Generación de columnas}: 
    \item \textbf{SCIP Y Pyscipopt}:
    
\end{itemize}


\end{document}


====================================================
% codigo comentado de las demas partes del problema
====================================================

%====================================================================
\section{Entrada en Calor}
%====================================================================

Esta sección presenta el desarrollo matemático detallado de los modelos para los problemas relacionados con la entrada en calor.

\subsection{Problema 1:}
\label{sec:probl1}

\subsubsection{Formulación Matemática}

\textbf{Variables:}
\begin{itemize}
    \item $x_a \in \{0,1\}$: 1 si el contenedor $a \in A$ es seleccionado, 0 en caso contrario
    \item $y_o \in \{0,1\}$: 1 si la bolsita $o \in O$ es seleccionada, 0 en caso contrario
\end{itemize}

\textbf{Parámetros:}
\begin{itemize}
    \item $B_a$: beneficio del contenedor $a$
    \item $B_{oi}$: beneficio de la bolsita $o$ para el ítem $i$
    \item $U_{oi}$: cantidad de ítems del tipo $i$ en la bolsita $o$
    \item $U_{ai}$: cantidad de ítems del tipo $i$ en el contenedor $a$
\end{itemize}

\textbf{Función Objetivo:}
\begin{equation}
\max \quad \sum_{a \in A} B_a \, x_a + \sum_{o \in O} \sum_{i} B_{oi} \, y_o
\end{equation}

\textbf{Restricciones:}
\begin{align}
& \sum_{a \in A} x_a = 1 \\[6pt]
& \sum_{a \in A} U_{ai} \, x_a \geq \sum_{o \in O} U_{oi} \, y_o, \quad \forall i \\
& x_a \in \{0,1\}, \quad \forall a \in A \\
& y_o \in \{0,1\}, \quad \forall o \in O
\end{align}

\clearpage

\subsection{Problema 2:}
\label{sec:probl2}

\subsubsection{Formulación Matemática}
\textbf{Variables:}
\begin{itemize}
    \item $x_a \in \{0,1\}$: 1 si el contenedor $a \in A$ es seleccionado, 0 en caso contrario
    \item $y_o \in \{0,1\}$: 1 si la bolsita $o \in O$ es seleccionada, 0 en caso contrario
\end{itemize}

\textbf{Parámetros:}
\begin{itemize}
    \item $B_a$: beneficio del contenedor $a$
    \item $B_{oi}$: beneficio de la bolsita $o$ para el ítem $i$
    \item $U_{oi}$: cantidad de ítems del tipo $i$ en la bolsita $o$
    \item $U_{ai}$: cantidad de ítems del tipo $i$ en el contenedor $a$
\end{itemize}

\textbf{Función Objetivo:}
\begin{equation}
\max \quad \sum_{a \in A} B_a x_a + \sum_{o \in O} \sum_{i} B_{oi} y_o
\end{equation}

\textbf{Restricciones:}
\begin{equation}
\sum_{a \in A} x_a = 1
\end{equation}

\begin{equation}
\sum_{a \in A} U_{ai} x_a \geq \sum_{o \in O} U_{oi} y_o, \quad \forall i
\end{equation}

\begin{equation}
x_a \in \{0,1\}, \quad \forall a \in A
\end{equation}

\begin{equation}
y_o \in \{0,1\}, \quad \forall o \in O
\end{equation}

\clearpage

%====================================================================
\section{El Desafió}
%====================================================================

Esta sección presenta el desarrollo matemático detallado de los modelos y sus implementación en Python para la los problemas del desafió.

\subsection{Primera parte:}
\label{sec:variante1}

\subsubsection{Formulación Matemática}

\textbf{Conjuntos e Índices:}
\begin{itemize}
    \item $O = \{0, 1, \ldots, o{-}1\}$: Conjunto de órdenes
    \item $I = \{0, 1, \ldots, i{-}1\}$: Conjunto de elementos o productos
    \item $A$: Conjunto de pasillos disponibles
\end{itemize}

\textbf{Parámetros:}
\begin{itemize}
    \item $W_{io}$: Cantidad del elemento $i$ requerido por la orden $o$
    \item $S_{ia}$: Cantidad del elemento $i$ disponible en el pasillo $a$
    \item $LB$: Límite inferior de unidades a recolectar
    \item $UB$: Límite superior de unidades a recolectar
    \item $P$: Cantidad de pasillos a visitar
\end{itemize}

\textbf{Variables de Decisión:}
\begin{itemize}
    \item $x_o \in \{0,1\}$: Toma valor 1 si la orden $o$ es seleccionada, 0 en caso contrario
    \item $y_a \in \{0,1\}$: Toma valor 1 si el pasillo $a$ es seleccionado, 0 en caso contrario
\end{itemize}

\textbf{Función Objetivo:}
\begin{equation}
\max \quad \frac{1}{P} \sum_{o \in O} \sum_{i \in I} W_{io} \cdot x_o
\end{equation}

\textbf{Restricciones:}
\begin{align}
\sum_{o \in O} \sum_{i \in I} W_{io} \cdot x_o &\geq LB \label{eq:limite_inferior} \\[6pt]
\sum_{o \in O} \sum_{i \in I} W_{io} \cdot x_o &\leq UB \label{eq:limite_superior} \\[6pt]
\sum_{o \in O} W_{io} \cdot x_o &\leq \sum_{a \in A} S_{ia} \cdot y_a, \quad \forall i \in I \label{eq:disponibilidad} \\[6pt]
\sum_{a \in A} y_a &= P \label{eq:pasillos_fijos}
\end{align}

\subsubsection{Implementación en Python}

La implementación se encuentra en \texttt{parte1.py} y utiliza PuLP para la optimización:

\begin{lstlisting}[language=Python, caption=Implementación clave de la parte 1]

\end{lstlisting}

\clearpage

\subsection{Segunda parte:}
\label{sec:variante2}

\subsubsection{Formulación Matemática}

\textbf{Conjuntos:}
\begin{itemize}
    \item $O$: conjunto de órdenes
    \item $I$: conjunto de elementos
    \item $A_0 \subseteq A$: conjunto de pasillos preseleccionados
    \item $A'$: pasillos a visitar
\end{itemize}

\textbf{Parámetros:}
\begin{itemize}
    \item $W_{io}$: cantidad del elemento $i$ requerido por la orden $o$
    \item $S_{ia}$: cantidad del elemento $i$ disponible en el pasillo $a$
    \item $LB$: límite inferior de unidades a recolectar
    \item $UB$: límite superior de unidades a recolectar
\end{itemize}

\textbf{Variables de Decisión:}
\begin{itemize}
    \item $x_o \in \{0,1\}$: Toma valor 1 si la orden $o$ es seleccionada, 0 en caso contrario
\end{itemize}

\textbf{Función Objetivo:}
\begin{equation}
\operatorname{max} \quad \sum_{o \in O} \sum_{i \in I} W_{io} \cdot x_o
\end{equation}


\textbf{Restricciones:}
\begin{align}
\sum_{o \in O} \sum_{i \in I} W_{io} \cdot x_o &\geq LB \\
\sum_{o \in O} \sum_{i \in I} W_{io} \cdot x_o &\leq UB \\
\sum_{o \in O} W_{io} \cdot x_o &\leq \sum_{a \in A'} S_{ia}, \quad \forall i \in I
\end{align}

\subsubsection{Implementación en Python}

La implementación en \texttt{parte2.py} incluye validaciones para verificar que las órdenes fijas cumplan con los límites de ola de trabajo:

\begin{lstlisting}[language=Python, caption=Implementación clave de la segunda parte]

\end{lstlisting}

\clearpage

\subsection{Tercera parte:}
\label{sec:variante3}

\subsubsection{Formulación Matemática}

\textbf{Conjuntos:}
\begin{itemize}
    \item $O = \{0, \ldots, n-1\}$: conjunto de órdenes
    \item $P = \{0, \ldots, m-1\}$: conjunto de pasillos
    \item $C$: conjunto de columnas válidas (índices $i$)
\end{itemize}

\textbf{Parámetros:}
\begin{itemize}
    \item $c_{io} \in \{0,1\}$: indica si la columna $i$ cubre la orden $o$
    \item $a_i \in P$: pasillo asociado a la columna $i$
    \item $M$: número máximo de pasillos a seleccionar
\end{itemize}

\textbf{Variables de Decisión:}
\begin{itemize}
    \item $z_i \in \{0,1\}$: 1 si se selecciona la columna $i$, 0 en caso contrario
    \item $y_a \in \{0,1\}$: 1 si se selecciona el pasillo $a$, 0 en caso contrario
\end{itemize}

\textbf{Función Objetivo:}
\begin{equation}
\max \quad \sum_{i \in C} \left(\sum_{o \in O} c_{io}\right) z_i
\end{equation}

\textbf{Restricciones:}
\begin{align}
&\sum_{i \in C} c_{io} \, z_i \leq 1, \quad \forall o \in O \\
&z_i \leq y_{a_i}, \quad \forall i \in C \\
&\sum_{a \in P} y_a = M
\end{align}


\subsubsection{Implementación en Python}

El archivo \texttt{parte3.py} implementa el algoritmo completo:

\begin{lstlisting}[language=Python, caption=Algoritmo principal de generación de columnas]

\end{lstlisting}

\clearpage